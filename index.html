<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>sASCH – Mandelbrot</title>
<style>
  /* ---------- Overlay (logo + 3 lines) ---------- */
  :root{
    --hero-top-desktop: 12vh;
    --hero-top-mobile: 8vh;
    --text-alpha: 0.65;
    --shadow-alpha: 0.15;
  }
  html,body{height:100%; margin:0; background:#000;}
  #mandelbrot-bg{position:fixed; inset:0; z-index:-1; pointer-events:none;}
  #mb-canvas{width:100%; height:100%; display:block;}

  .hero-overlay{
    position:fixed; inset:0; z-index:5; pointer-events:none;
    display:grid; place-items:start center; padding:0 4vw;
    padding-top: env(safe-area-inset-top, 0px);
  }
  .hero-box{
    margin-top: var(--hero-top-desktop);
    text-align:center; color:rgba(255,255,255,var(--text-alpha));
    max-width:1100px; width:100%; line-height:1.28;
  }
  .hero-logo{
    width:min(15vw,160px); height:auto; margin:0 auto 1.2vh auto; display:block; opacity:0;
    animation:fadeUp 900ms ease-out 200ms forwards;
    filter:drop-shadow(0 1px 5px rgba(0,0,0,.25));
  }
  .hero-line{
    font-weight:300; letter-spacing:.01em; opacity:0; transform:translateY(5px);
    text-shadow:0 1px 5px rgba(0,0,0,var(--shadow-alpha));
  }
  .l2{ font-size:clamp(14px,1.6vw,20px); animation:fadeUp 700ms ease-out 1200ms forwards; }
  .l3{ font-size:clamp(14px,1.6vw,20px); animation:fadeUp 700ms ease-out 2200ms forwards; }
  .l4{ font-size:clamp(14px,1.6vw,20px); animation:fadeUp 700ms ease-out 3200ms forwards; }

  @media (max-width: 768px){
    .hero-box{ margin-top: var(--hero-top-mobile); }
    .hero-logo{ width:min(38vw,140px); }
    .l2, .l3, .l4{ font-size:clamp(13px,4vw,18px); }
  }

  @keyframes fadeUp{ from{opacity:0;transform:translateY(10px);} to{opacity:1;transform:translateY(0);} }
  @media (prefers-reduced-motion: reduce){ .hero-logo,.hero-line{ animation:none; opacity:1; transform:none; } }

  /* ---------- Expert mode UX fixes ---------- */
  .mb-expert { overscroll-behavior: none; }
  .mb-expert #mb-canvas { touch-action: none; }

  /* ---------- Expert UI ---------- */
  .mb-ui{
    position:fixed; right:12px; bottom:12px; z-index:6;
    display:flex; gap:10px; align-items:flex-end;
    font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color:#eee; pointer-events:none;
  }
  .mb-btn{
    pointer-events:auto; cursor:pointer;
    background:rgba(255,255,255,.08); color:#fff; border:1px solid rgba(255,255,255,.15);
    padding:8px 10px; border-radius:10px; backdrop-filter: blur(6px);
  }
  .mb-btn.active{ background:rgba(88,170,255,.25); border-color:rgba(88,170,255,.5); }
  .mb-panel{
    display:none; pointer-events:auto;
    background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.12);
    padding:10px 12px; border-radius:12px; backdrop-filter: blur(6px);
    min-width:240px;
  }
  .mb-panel.on{ display:block; }
  .mb-row{ display:flex; align-items:center; gap:10px; margin:6px 0; }
  .mb-row label{ flex:0 0 74px; color:#ddd; }
  .mb-row input[type=range]{ width:140px; }
  .mb-hint{ color:#bbb; font-size:12px; margin-top:6px; }
  .mb-select{ background:rgba(255,255,255,.08); color:#fff; border:1px solid rgba(255,255,255,.15); border-radius:8px; padding:6px 8px; }
</style>
</head>
<body>

<!-- Background canvas -->
<div id="mandelbrot-bg"><canvas id="mb-canvas"></canvas></div>

<!-- Overlay -->
<div class="hero-overlay">
  <div class="hero-box">
    <img class="hero-logo" src="https://sasch.odoo.com/web/image/website/1/logo/sasch.ca?unique=83efd14" alt="sASCH logo">
    <div class="hero-line l2">Technology Solutions</div>
    <div class="hero-line l3">Automation</div>
    <div class="hero-line l4">Innovative Projects</div>
  </div>
</div>

<!-- Mandelbrot renderer -->
<script>
(function () {
  const SETTINGS = {
    DPR_CAP: 1.25,
    FPS: 30,
    START_SCALE: 3.0,
    END_SCALE: 1e-6,
    DIVE_SECONDS: 36,
    ROT_SPEED: 0.02,
    ITER_MIN: 60,
    ITER_MAX: 600,
    MOTION_OK: !window.matchMedia('(prefers-reduced-motion: reduce)').matches
  };

  const canvas = document.getElementById('mb-canvas');
  const gl = canvas.getContext('webgl', { antialias:false, preserveDrawingBuffer:false });
  if (!gl || !SETTINGS.MOTION_OK) { return; }

  const vs = `
    attribute vec2 a_pos;
    void main(){ gl_Position = vec4(a_pos,0.0,1.0); }
  `;
  const fs = `
    precision highp float;
    uniform vec2 u_res;
    uniform vec2 u_center;
    uniform float u_scale;
    uniform float u_rot;
    uniform float u_iter;
    uniform float u_time;
    vec3 palette(float t){ float v = mix(0.5, 0.0, t); return vec3(v); }
    void main(){
      vec2 p = (gl_FragCoord.xy - 0.5*u_res) / u_res.y;
      float cs = cos(u_rot), sn = sin(u_rot);
      vec2 pr = mat2(cs, -sn, sn, cs) * p;
      vec2 c = u_center + pr * u_scale;
      vec2 z = vec2(0.0);
      float m2 = 0.0, it = 0.0, maxIter = u_iter;
      const float ESC = 256.0;
      bool escaped = false;
      for (int i = 0; i < 1200; i++) {
        if (it >= maxIter) break;
        vec2 z2 = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
        z = z2; m2 = dot(z,z); it += 1.0;
        if (m2 > ESC) { escaped = true; break; }
      }
      if (!escaped){ gl_FragColor = vec4(0.0,0.0,0.0,1.0); return; }
      float mu = it - log2(log2(m2));
      float tcol = clamp(mu / maxIter, 0.0, 1.0);
      gl_FragColor = vec4(palette(tcol), 1.0);
    }
  `;

  function make(gl, type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
    return s;
  }
  const prog = gl.createProgram();
  gl.attachShader(prog, make(gl, gl.VERTEX_SHADER, vs));
  gl.attachShader(prog, make(gl, gl.FRAGMENT_SHADER, fs));
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
  gl.useProgram(prog);

  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1, 1,-1,1,1,-1,1]), gl.STATIC_DRAW);
  const loc = {
    a_pos: gl.getAttribLocation(prog, 'a_pos'),
    u_res: gl.getUniformLocation(prog, 'u_res'),
    u_center: gl.getUniformLocation(prog, 'u_center'),
    u_scale: gl.getUniformLocation(prog, 'u_scale'),
    u_rot: gl.getUniformLocation(prog, 'u_rot'),
    u_iter: gl.getUniformLocation(prog, 'u_iter'),
    u_time: gl.getUniformLocation(prog, 'u_time')
  };
  gl.enableVertexAttribArray(loc.a_pos);
  gl.vertexAttribPointer(loc.a_pos, 2, gl.FLOAT, false, 0, 0);

  function resize(){
    const dpr = Math.min(window.devicePixelRatio || 1, SETTINGS.DPR_CAP);
    const w = Math.floor(canvas.clientWidth * dpr);
    const h = Math.floor(canvas.clientHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; gl.viewport(0,0,w,h); }
  }
  const ro = new ResizeObserver(resize); ro.observe(canvas);

  const spots = [
    {name:'Seahorse Valley', c:[-0.743643887037151, 0.13182590420533]},
    {name:'Elephant Valley', c:[-0.74529, 0.11272]},
    {name:'Valley of Birds', c:[-1.25066, 0.02012]},
    {name:'Spiral Seahorses', c:[-0.77568377, 0.13646737]},
    {name:'Cauliflower', c:[0.001643721971153, -0.822467633298876]},
    {name:'Main Bulb Edge', c:[-0.10109636384562, 0.95628651080914]}
  ];
  function pickNewCenter(prev){
    let s; do { s = spots[Math.floor(Math.random()*spots.length)].c; }
    while (prev && Math.hypot(prev[0]-s[0], prev[1]-s[1]) < 1e-9);
    return s.slice();
  }

  let center = pickNewCenter(null);
  let diveStart = performance.now() / 1000;
  let startScale = SETTINGS.START_SCALE;
  const baseSpeed = Math.log(startScale / SETTINGS.END_SCALE) / SETTINGS.DIVE_SECONDS;

  const frameInterval = 1 / SETTINGS.FPS;
  let acc = 0;
  let last = performance.now() / 1000;

  /* Expert control state */
  let expertMode = false;
  let speedMult = 1.0;
  let manualScale = startScale;
  let manualCenter = center.slice();
  let rotOverride = null;

  function drawFrame(now, dt){
    resize();
    const tsec = now - diveStart;

    let scale, rot;
    if (expertMode) {
      manualScale *= Math.exp(-baseSpeed * speedMult * dt);
      scale = manualScale;
      center = manualCenter;
      rot = (rotOverride == null) ? SETTINGS.ROT_SPEED * (now - diveStart) : rotOverride;
    } else {
      scale = startScale * Math.exp(-baseSpeed * Math.max(0, tsec));
      rot = SETTINGS.ROT_SPEED * (now - diveStart);
    }

    const iterCap = expertMode ? Math.max(SETTINGS.ITER_MAX, 900) : SETTINGS.ITER_MAX;
    const iterHint = Math.min(iterCap, SETTINGS.ITER_MIN + Math.log2(Math.max(1, SETTINGS.START_SCALE/scale))*30.0);

    gl.uniform2f(loc.u_res, canvas.width, canvas.height);
    gl.uniform2f(loc.u_center, center[0], center[1]);
    gl.uniform1f(loc.u_scale, scale);
    gl.uniform1f(loc.u_rot, rot);
    gl.uniform1f(loc.u_iter, iterHint);
    gl.uniform1f(loc.u_time, now);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    if (!expertMode && tsec > SETTINGS.DIVE_SECONDS) {
      center = pickNewCenter(center);
      diveStart = now; startScale = SETTINGS.START_SCALE;
    }
  }

  let rafId;
  function loop(){
    const now = performance.now() / 1000;
    const dt = now - last; last = now; acc += dt;
    if (acc >= frameInterval) { drawFrame(now, acc); acc = 0; }
    rafId = requestAnimationFrame(loop);
  }
  rafId = requestAnimationFrame(loop);

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) cancelAnimationFrame(rafId);
    else { last = performance.now() / 1000; acc = 0; rafId = requestAnimationFrame(loop); }
  });

  /* Expose tiny API for Expert UI */
  window.MB = {
    enableExpert(flag){
      expertMode = !!flag;
      if (expertMode) {
        manualScale = startScale * Math.exp(-baseSpeed * Math.max(0, (performance.now()/1000 - diveStart)));
        manualCenter = center.slice();
      }
    },
    setSpeedMult(m){ speedMult = Math.max(0, m); },
    getState(){ return { expertMode, center: center.slice(), scale: expertMode ? manualScale : startScale, canvas, spots }; },
    pan(dx, dy){
      const aspectScale = (expertMode ? manualScale : startScale) / canvas.height;
      manualCenter[0] -= dx * aspectScale;
      manualCenter[1] += dy * aspectScale;
    },
    zoomAt(clientX, clientY, factor){
      const rect = canvas.getBoundingClientRect();
      const x = (clientX - rect.left) * (canvas.width / rect.width);
      const y = (clientY - rect.top)  * (canvas.height / rect.height);
      const aspectScale = manualScale / canvas.height;
      const cx = (x - canvas.width*0.5) * aspectScale;
      const cy = (y - canvas.height*0.5) * aspectScale;
      manualCenter[0] += cx * (1.0 - 1.0/factor);
      manualCenter[1] -= cy * (1.0 - 1.0/factor);
      manualScale /= factor;
    },
    setRotation(r){ rotOverride = r; },
    resetRotation(){ rotOverride = null; },
    jumpToSpot(idx){
      const s = spots[idx|0]; if (!s) return;
      manualCenter = s.c.slice();
      manualScale = SETTINGS.START_SCALE;
      diveStart = performance.now() / 1000;
    }
  };
})();
</script>

<!-- Expert Mode UI + logic -->
<div class="mb-ui">
  <button id="mb-toggle" class="mb-btn">Expert Mode</button>
  <div id="mb-panel" class="mb-panel">
    <div class="mb-row">
      <label>Speed</label>
      <input id="mb-speed" type="range" min="0" max="4" value="1" step="0.05">
      <span id="mb-speed-val">1.0x</span>
    </div>
    <div class="mb-row">
      <label>Waypoints</label>
      <select id="mb-spot" class="mb-select"></select>
    </div>
    <div class="mb-row">
      <button id="mb-zoom-in" class="mb-btn">+</button>
      <button id="mb-zoom-out" class="mb-btn">−</button>
      <button id="mb-reset-rot" class="mb-btn" title="Reset rotation">⟳</button>
    </div>
    <div class="mb-hint">Scroll/pinch to zoom. Drag to pan. Arrows pan. Shift = faster.</div>
  </div>
</div>

<script>
(function(){
  if (!window.MB) return;

  const toggle = document.getElementById('mb-toggle');
  const panel = document.getElementById('mb-panel');
  const speed = document.getElementById('mb-speed');
  const speedVal = document.getElementById('mb-speed-val');
  const zoomIn = document.getElementById('mb-zoom-in');
  const zoomOut = document.getElementById('mb-zoom-out');
  const resetRot = document.getElementById('mb-reset-rot');
  const spotSel = document.getElementById('mb-spot');

  function populateSpots(){
    const st = MB.getState();
    spotSel.innerHTML = '';
    st.spots.forEach((s, i) => {
      const opt = document.createElement('option');
      opt.value = i; opt.textContent = s.name;
      spotSel.appendChild(opt);
    });
  }
  populateSpots();

  let enabled = false;
  function setEnabled(flag){
    enabled = flag;
    toggle.classList.toggle('active', enabled);
    panel.classList.toggle('on', enabled);
    document.body.classList.toggle('mb-expert', enabled);
    MB.enableExpert(enabled);
    if (enabled) {
      const st = MB.getState();
      MB.zoomAt(st.canvas.width/2, st.canvas.height/2, 1.02); // instant nudge so you see detail
    }
  }
  toggle.addEventListener('click', () => setEnabled(!enabled));

  function applySpeed(){
    const v = parseFloat(speed.value || '1');
    MB.setSpeedMult(v);
    speedVal.textContent = v.toFixed(1) + 'x';
  }
  speed.addEventListener('input', applySpeed);
  applySpeed();

  spotSel.addEventListener('change', e => MB.jumpToSpot(parseInt(e.target.value, 10)));

  function zoomButton(factor){
    const state = MB.getState();
    const rect = state.canvas.getBoundingClientRect();
    MB.zoomAt(rect.left + rect.width/2, rect.top + rect.height/2, factor);
  }
  zoomIn.addEventListener('click', () => zoomButton(1.3));
  zoomOut.addEventListener('click', () => zoomButton(1/1.3));
  resetRot.addEventListener('click', () => MB.resetRotation());

  // Wheel
  window.addEventListener('wheel', e => {
    if (!enabled) return;
    const factor = e.deltaY < 0 ? 1.1 : 1/1.1;
    MB.zoomAt(e.clientX, e.clientY, factor);
    e.preventDefault();
  }, { passive:false });

  // Mouse drag
  let dragging = false, lastX = 0, lastY = 0;
  window.addEventListener('mousedown', e => { if (!enabled) return; dragging = true; lastX = e.clientX; lastY = e.clientY; });
  window.addEventListener('mousemove', e => {
    if (!enabled || !dragging) return;
    MB.pan(e.clientX - lastX, e.clientY - lastY);
    lastX = e.clientX; lastY = e.clientY;
  });
  window.addEventListener('mouseup', () => { dragging = false; });

  // Touch: pan + pinch (with page scroll suppressed)
  let touchZoomBase = null;
  let lastTouchX = 0, lastTouchY = 0;

  window.addEventListener('touchstart', e => {
    if (!enabled) return;
    if (e.touches.length === 1) {
      lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
      const dx = e.touches[1].clientX - e.touches[0].clientX;
      const dy = e.touches[1].clientY - e.touches[0].clientY;
      touchZoomBase = Math.hypot(dx, dy);
    }
  }, { passive:true });

  window.addEventListener('touchmove', e => {
    if (!enabled) return;
    e.preventDefault();
    if (e.touches.length === 1) {
      const x = e.touches[0].clientX, y = e.touches[0].clientY;
      MB.pan(x - lastTouchX, y - lastTouchY);
      lastTouchX = x; lastTouchY = y;
    } else if (e.touches.length === 2 && touchZoomBase) {
      const dx = e.touches[1].clientX - e.touches[0].clientX;
      const dy = e.touches[1].clientY - e.touches[0].clientY;
      const dist = Math.hypot(dx, dy);
      const raw = dist / touchZoomBase;
      const factor = Math.min(1.5, Math.max(1/1.5, raw));
      const cx = (e.touches[0].clientX + e.touches[1].clientX)/2;
      const cy = (e.touches[0].clientY + e.touches[1].clientY)/2;
      MB.zoomAt(cx, cy, factor);
      touchZoomBase = dist;
    }
  }, { passive:false });

  window.addEventListener('touchend', () => { touchZoomBase = null; }, { passive:true });

  // Keyboard
  window.addEventListener('keydown', e => {
    if (!enabled) return;
    const fast = e.shiftKey ? 40 : 15;
    if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','+','-','=','_'].includes(e.key)) e.preventDefault();
    if (e.key === 'ArrowLeft')  MB.pan(-fast, 0);
    if (e.key === 'ArrowRight') MB.pan(fast, 0);
    if (e.key === 'ArrowUp')    MB.pan(0, -fast);
    if (e.key === 'ArrowDown')  MB.pan(0, fast);
    if (e.key === '+' || e.key === '=') zoomButton(1.15);
    if (e.key === '-' || e.key === '_') zoomButton(1/1.15);
  });
})();
</script>

</body>
</html>
